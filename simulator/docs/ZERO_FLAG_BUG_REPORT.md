# Звіт про помилку: Неправильна робота Zero Flag Detection

**Дата:** 13 січня 2026
**Статус:** Критична помилка
**Компонент:** ALU Hub — схема визначення Zero Flag

---

## Опис проблеми

При виконанні програми з умовним переходом `jz` (jump if zero), інструкція **завжди виконує стрибок**, незалежно від значення акумулятора.

### Тестова програма

```asm
ldi-ac-[byte] 0x0A   ; AC = 10 (не нуль!)
cmpi-[byte] 0x05     ; порівняти AC з 5 (10 ≠ 5, Z має бути 0)
jz-[word] 0x000B     ; НЕ повинен стрибати, бо Z=0
```

### Очікувана vs Фактична поведінка

| Параметр | Очікувано | Фактично |
|----------|-----------|----------|
| AC після `ldi` | 0x0A | 0x0A ✓ |
| Z після `cmpi` | 0 | **1** ✗ |
| Стрибок `jz` | НІ | **ТАК** ✗ |
| Кінцевий PC | 0x0007 | **0x000B** ✗ |

---

## Діагностика

### Крок 1: Моніторинг сигналу STATE10 (Zero Flag)

Запуск діагностичного скрипта `diag_jz.py`:

```
Cyc | PC     | Instr | AC   | ZeroOut | Mnemonic
------------------------------------------------------------
 11 | 0x0004 | 0xDA  | 0x0A | Z=0     | cmpi-[byte]
 12 | 0x0004 | 0xDA  | 0x0A | Z=1     | cmpi-[byte]  ← ПОМИЛКА!
 16 | 0x0005 | 0x6B  | 0x0A | Z=1     | jz-[word]
 22 | 0x000B | 0x6B  | 0x0A | Z=1     | jz-[word]    ← Стрибнув!
```

**Висновок:** Флаг Z неправильно встановлюється в 1 після `cmpi`.

### Крок 2: Моніторинг виходу ALU

Запуск діагностичного скрипта `diag_alu.py`:

```
Cyc | PC     | AC   | ALU  | Z   | ZO  | Mnemonic
------------------------------------------------------------
 11 | 0x0004 | 0x0A | 0x05 | Z=0 | ZO=1 | cmpi-[byte]  ← ZO=1 при ALU≠0!
 12 | 0x0004 | 0x0A | 0x74 | Z=1 | ZO=1 | cmpi-[byte]
```

**Критична помилка:** `ZO=1` (Zero Output HIGH) коли `ALU=0x05` (не нуль!).

---

## Аналіз схеми

### Компоненти Zero Detection

Схема визначення Zero flag знаходиться в `alu_hub.frp` і використовує:
- **U10** — 74LS02 (quad NOR) для нижніх біт F0-F3
- **U9** — 74LS02 (quad NOR) для верхніх біт F4-F7

### Поточна логіка (НЕПРАВИЛЬНА)

```
U10 (нижні біти):
├── Gate 1: Y1 = NOR(F0, F1)
├── Gate 2: Y2 = NOR(F2, F3)
├── Gate 3: Y3 = NOR(Y1, Y2)  ← Проблемний каскад!
└── Gate 4: ALUZO = NOT(Y4_u9)

U9 (верхні біти):
├── Gate 1: Y1 = NOR(F4, F5)
├── Gate 2: Y2 = NOR(F6, F7)
├── Gate 3: Y3 = NOR(Y1, Y2)
└── Gate 4: Y4 = NOR(Y3_u9, Y3_u10)
```

### Математичний доказ помилки

**Тест 1: Всі біти = 0 (результат 0x00)**
```
U10: Y1 = NOR(0,0) = 1
     Y2 = NOR(0,0) = 1
     Y3 = NOR(1,1) = 0  ← НЕ ТАК!

U9:  Y3 = NOR(1,1) = 0
     Y4 = NOR(0,0) = 1

ALUZO = NOT(1) = 0  ← НЕПРАВИЛЬНО! Має бути 1!
```

**Тест 2: F0 = 1, решта = 0 (результат 0x01)**
```
U10: Y1 = NOR(1,0) = 0
     Y2 = NOR(0,0) = 1
     Y3 = NOR(0,1) = 0

U9:  Y3 = 0
     Y4 = NOR(0,0) = 1

ALUZO = NOT(1) = 0  ← Той самий результат!
```

**Висновок:** ALUZO завжди = 0, незалежно від вхідних даних.

### Причина помилки

Каскад `NOR → NOR` реалізує формулу:
```
NOR(NOR(A,B), NOR(C,D)) = (A OR B) AND (C OR D)
```

Це **НЕ еквівалентно** потрібній функції:
```
ZERO = NOT(F0 OR F1 OR F2 OR F3 OR F4 OR F5 OR F6 OR F7)
```

---

## Вплив на систему

### Зламані інструкції

| Мнемоніка | Опис | Статус |
|-----------|------|--------|
| `jz-[word]` | Jump if Zero | ❌ Завжди стрибає |
| `jnz-[word]` | Jump if Not Zero | ❌ Ніколи не стрибає |
| `jzx` | Jump if Zero (indirect) | ❌ Завжди стрибає |
| `jnzx` | Jump if Not Zero (indirect) | ❌ Ніколи не стрибає |
| `cz-[word]` | Call if Zero | ❌ Завжди викликає |
| `cnz-[word]` | Call if Not Zero | ❌ Ніколи не викликає |
| `rz` | Return if Zero | ❌ Завжди повертає |
| `rnz` | Return if Not Zero | ❌ Ніколи не повертає |

**Всього:** 8 інструкцій повністю непрацездатні.

---

## Рекомендації щодо виправлення

### Варіант 1: Апаратне виправлення (рекомендовано)

Замінити каскад NOR→NOR на правильну логіку:

**Опція A: Використати 74LS30 (8-input NAND) + інвертор**
```
ZERO = NOT(NAND(F0,F1,F2,F3,F4,F5,F6,F7))
     = NOT(NOT(F0 AND F1 AND ... AND F7))
```
*Примітка: Потрібно інвертувати входи!*

**Опція B: Правильний каскад з AND**
```
        F0 ──┬── NOR ──┐
        F1 ──┘         │
        F2 ──┬── NOR ──┼── AND ──┐
        F3 ──┘         │         │
        F4 ──┬── NOR ──┘         ├── ALUZO
        F5 ──┘                   │
        F6 ──┬── NOR ────────────┘
        F7 ──┘
```

### Варіант 2: Виправлення в симуляторі

Модифікувати файл `simulator/netlists/alu_hub.frp`:
1. Змінити підключення U9/U10 gates
2. Або додати новий компонент для Zero detection

### Варіант 3: Обхідний шлях в мікрокоді

Не рекомендується — потребує повного перепроектування мікрокоду.

---

## Файли для аналізу

| Файл | Опис |
|------|------|
| `simulator/netlists/alu_hub.frp` | Netlist ALU Hub (містить помилку) |
| `simulator/diag_jz.py` | Діагностика JZ інструкції |
| `simulator/diag_alu.py` | Діагностика ALU виходів |
| `schematics/alu_hub/` | KiCad схема ALU Hub |

---

## Історія змін

| Дата | Автор | Опис |
|------|-------|------|
| 2026-01-13 | GitHub Copilot | Початкова діагностика та звіт |

---

## Додаток: Діагностичні скрипти

### diag_jz.py
Моніторить сигнал STATE10 (Zero flag) під час виконання тестової програми.

### diag_alu.py
Моніторить виходи ALU (F0-F7) та сигнали ZO/Z для аналізу логіки Zero detection.

### Запуск діагностики
```bash
cd /Users/nikitalenyk/Desktop/Cpu8/simulator
python3 diag_jz.py
python3 diag_alu.py
```
