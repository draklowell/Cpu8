# Документація assembler CPU8/16

## 1. Вступ

CPU8/16 — це навчальний кастомний асемблер для однойменного 8-бітного процесора з вибірковою підтримкою 16-бітних операцій. Джерельні файли проходять через GCC-препроцесор (`cpp`), тому можна використовувати `#define`, `#include`, `#ifdef` та інші директиви. Процес складання виконується у два проходи: **Pass1** збирає мітки та формує таблицю символів, а **Pass2** підставляє адреси й генерує машинний код. Результатом є плоский ROM-образ на 16 КБ, заповнений байтами `0xFF`, у який потрапляють секції `.text` та `.rodata`.

## 2. Основи синтаксису

Кожен рядок інструкції має формат:

```
<label>:    <mnemonic> <operand1>, <operand2>   ; optional comment
```

* **Мітки** оголошуються через `label:` і можуть використовуватись як адреси.
* **Регістр** нечутливий до регістру запису: `AC`, `ac`, `Ac` — тотожні.
* **Числові літерали**:
  * десяткові: `13`
  * шістнадцяткові: `0x12FF`
  * двійкові: `0b10101010`

## 3. Секції та директиви

Нижче наведені стандартні секції з прикладами використання:

### `.text` — код

```asm
.text
.global main
main:
    ldi ac, 0x01
    hlt
```

### `.rodata` — константи

```asm
.rodata
msg: .asciz "Hi"
```

### `.data` — ініціалізовані змінні
>
> **Примітка:** наразі секція `.data` не копіюється до RAM автоматично, але її можна використовувати для явних таблиць у ROM.

```asm
.data
init_value: .word 0x1234
```

### `.bss` — неініціалізовані змінні

У секції `.bss` дані **не** емітяться — асемблер лише підраховує розмір.

```asm
.bss
array:
    .res 64    ; резервує 64 байти, не емітиться у бінарник
```

### `.globl` / `.extern`

```asm
.globl main
.extern memcpy
```

### Директиви розміщення даних

* `.byte`, `.word`, `.ascii`, `.asciz` — формують байти у поточній секції (**заборонено** у `.bss`).
* `.res` — резервує байти лише у `.bss`.

## 4. Адресація і операнди

| Тип             | Приклад          | Опис                              |
|-----------------|------------------|-----------------------------------|
| Імедіатна       | `ldi ac, 0x12`   | Завантажує константу у регістр.   |
| Абсолютна пам’ять | `ld ac, [label]` | Читає байт із адреси в пам’яті.   |
| Регістр до регістра | `mov xh, ac`   | Копіює значення між регістрами.   |
| 16-бітні адреси | `ldi z, label`   | Завантажує повну адресу мітки.    |

⚠️(NOT SUPPORTED YET) **Помилка:** якщо спробувати завантажити 16-бітне значення в 8-бітний регістр, з’явиться повідомлення:

```
error: cannot load 16-bit immediate into 8-bit register 'zl'
note: use 'ld zl, [label]' if you meant to load a byte
```

## 5. Мнемоніки та формати інструкцій

Інструкції групуються за функціями, подібно до документації AVR:

* **LDI / LD / ST** — завантаження та збереження даних (безпосередні, абсолютні, через покажчики).
* **MOV / PUSH / POP** — передавання даних між регістрами та стеком.
* **CALL / RET / JMP / JZ / JC / ...** — передавання керування.
* **ADD / SUB / NAND / NOR / XOR / NOT / INC / DEC / ...** — арифметико-логічні операції.

Кожна канонічна форма зберігається у таблиці `table.csv`. Людські записи на кшталт `mov ac, xh` автоматично нормалізуються до канонічних імен із дефісами (`mov-ac-xh`) під час підбору опкодів.

## 6. Приклади повних програм

### Приклад із константою в `.rodata`

```asm
.rodata
msg: .asciz "Hi"

.text
.global main
main:
    ldi z, msg
    ld ac, [msg]
    intd
    shl
    inte
    hlt
```

### Приклад із `.bss`

```asm
.bss
n: .res 4

.text
main:
    ldi sp, 0xFFFF
    st [n], ac
    hlt
```

## 7. Diagnostics — типові повідомлення

| Помилка                                      | Пояснення                                      |
|----------------------------------------------|------------------------------------------------|
| `undefined symbol`                           | Посилання на мітку, яка не визначена.          |
| `invalid operands for instruction`           | Невідповідні операнди, наприклад `mov ac, 0x12`.|
| `cannot load 16-bit immediate into 8-bit register` | Спроба `ldi zl, label` або `ldi ac, 0x1234`. |
| `.byte not allowed in .bss`                  | Заборонені директиви в секції `.bss`.          |
| `unknown instruction`                        | Мнемоніка відсутня у `table.csv`.              |

---

## CLI утиліти

### `asm_cli`

```bash
Usage: asm_cli [options] <input.asm> [output]
Options:
  -o <file>         Output path (bin or obj)
  --object          Emit relocatable object (.o)
  --no-preprocess   Do not run external preprocessor
  --verbose         Print section size summary
  --help            Show this help message
```

* **Базова збірка ROM** (16 КБ образ, заповнений `0xFF`):

  ```bash
  ./asm_cpu program.S build/program.bin
  ```

* **Вивід обʼєкта для лінкера**:

  ```bash
  ./asm_cpu --object -o build/program.o program.S
  ```

  У цьому режимі `.text`, `.rodata` та релокації зберігаються для подальшого лінкування.

* **Вимкнення зовнішнього препроцесора** — корисно, якщо файл уже пройшов `cpp` або препроцесор не потрібен (притримуємось конвенції, що .s файли не потребують препроцесингу, а .S файли — потребують):

  ```bash
  ./asm_cpu --no-preprocess program_pp.S build/program.bin
  ```

* **Додаткові підказки про розмір секцій**:

  ```bash
  ./asm_cpu --verbose program.S build/program.bin
  ```

  Після успішної збірки утиліта виведе кількість байтів у `.text` та `.rodata`, а також сумарний розмір ROM.

### `ld_cli`

```bash
Usage: ld <out.bin> <in1.o> <in2.o> ... [--map <file.map>] [--entry <sym>] [--rom-size N] [--rom-fill 0xFF]
```

* **Стандартне лінкування кількох обʼєктів**:

  ```bash
  ./ld_cpu build/program.bin build/startup.o build/main.o
  ```

  За замовчуванням точка входу — символ `main`, а результатом буде 16 КБ ROM із заповненням `0xFF`.

* **Зміна точки входу**:

  ```bash
  ./ld_cpu build/program.bin build/startup.o build/main.o --entry reset
  ```

* **Генерація map-файлу з розкладкою символів**:

  ```bash
  ./ld_cpu build/program.bin build/main.o --map build/program.map
  ```

* **Контроль розміру та заповнення ROM** (байтове значення можна задавати у будь-якій нотації, що підтримується `std::stoul`):

  ```bash
  ./ld_cpu build/program.bin build/main.o --rom-size 8192 --rom-fill 0x00
  ```
